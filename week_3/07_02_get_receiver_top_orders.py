top_heights = [6, 9, 5, 7, 4]

# [0, 0, 2, 2, 4] (목표)

# 초기화
# [0, 0, 0, 0, 0]

# <- <- <- <- <-
#  6  9  5  7  4  (탐색 후 7이 레이저 받는 탑임을 알게 됨, 원소는 사라져버려도 된다)
# [0, 0, 0, 0, 4]

# <- <- <- <-
#  6  9  5  7     (탐색 후 9가 레이저 받는 탑임을 알게 됨, 원소는 사라져버려도 된다)
# [0, 0, 0, 2, 4]

# <- <- <-
#  6  9  5        (탐색 후 9가 레이저 받는 탑임을 알게 됨, 원소는 사라져버려도 된다)
# [0, 0, 2, 2, 4]

# <- <-
#  6  9           (탐색 후 받는 탑이 없음을 알게 됨,  원소는 사라져버려도 된다)
# [0, 0, 2, 2, 4]

# <-
#  6              (탐색 후 받는 탑이 없음을 알게 됨,  원소는 사라져버려도 된다)
# [0, 0, 2, 2, 4]

# 이 구조로 봤을 때 원소가 맨 뒤에 거 먼저 하나씩 없어진다. 맨 뒤에 것이 하나씩 없어진다..?! -> 스택이란 자료구조를 활용했구나


def get_receiver_top_orders(heights):
    # 다 0으로 해서 초기화, 업데이트가 안되면 어차피 0이 반환되어야 하니까
    answer = [0] * len(heights)
    while heights:  # heights 가 빈 상태가 아닐 때까지라는 뜻
        height = heights.pop()  # 맨 뒤에있는 애한테 바로 접근해 삭제할 수 있는 친구, pop
        # 남은 배열 [6, 9, 5, 7]
        # 그리고 반복을 하는데 여기서 범위는 heights 의 현재 길이이고,
        # for idx in range
        # (len(5) - 1 # <- 인덱스 기준이니까, 0(==언제까지 할거냐, -1이어도 되는데 0인 이유는 첫 번째는 무조건 받는게 없으니), -1(==-1씩 줄어들겠다는 의미))
        for idx in range(len(heights) - 1, 0, -1):
            if heights[idx] > height:
                # idx + 1 의 값을 answer 에 몇 번째에 넣어야 하느냐..를 고민해보자!!!
                # 맨 뒤에 있는 인덱스에 접근을 해야함. 왜냐면 걔에 대한 정보니까 (배열 길이를 조절하고 없애준 정보를 이용한다 인덱스에)!!!
                # 스택에서 하나 뺀 다음에 그 하나의 인덱스를 알기 위해서는 현재 나와있는 스택의 길이가 그 인덱스다
                answer[len(heights)] = idx + 1
                # answer 값 올바르게 업데이트 되었다면 break
                break
    return answer


print(get_receiver_top_orders(top_heights))  # [0, 0, 2, 2, 4] 가 반환되어야 한다!
